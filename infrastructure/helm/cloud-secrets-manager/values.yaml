image:
  repositorySecretService: "europe-west10-docker.pkg.dev/cloud-secrets-manager/docker-images/secret-service"
  repositoryAuditService: "europe-west10-docker.pkg.dev/cloud-secrets-manager/docker-images/audit-service"
  tag: "latest"
  pullPolicy: IfNotPresent

secretService:
  replicaCount: 1
  port: 8080
  resources:
    requests:
      memory: "256Mi"
      cpu: "200m"
    limits:
      memory: "512Mi"
      cpu: "500m"

auditService:
  replicaCount: 1
  port: 8081
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"

serviceAccount:
  create: true
  annotations:
    # Workload Identity binding for secret-service
    iam.gke.io/gcp-service-account: "secret-service-dev@cloud-secrets-manager.iam.gserviceaccount.com"
  
# Separate service account configuration for audit-service
auditServiceAccount:
  create: true
  annotations:
    # Workload Identity binding for audit-service
    iam.gke.io/gcp-service-account: "audit-service-dev@cloud-secrets-manager.iam.gserviceaccount.com"

# Secrets Configuration
# Set to false if using External Secrets Operator (recommended for production)
createSecrets: false

# If createSecrets is true, these values will be used to create Kubernetes Secrets
# If createSecrets is false, these are ignored and you must ensure secrets exist via ESO
jwtSecret: "ignored-if-create-secrets-is-false"
aesKey: "ignored-if-create-secrets-is-false"

postgres:
  enabled: false # Disable local databases (using Cloud SQL)
  secretsDb:
    user: secrets_user  # Matches Terraform: ${db_name}_user
    # password: ignored-if-create-secrets-is-false (managed by ESO from GCP Secret Manager)
    db: secrets  # Database name in Cloud SQL
    storage: 10Gi
  auditDb:
    user: audit_user  # Matches Terraform: ${db_name}_user
    # password: ignored-if-create-secrets-is-false (managed by ESO from GCP Secret Manager)
    db: audit  # Database name in Cloud SQL
    storage: 10Gi

# Cloud SQL Configuration
cloudSql:
  enabled: true
  connectionName: "cloud-secrets-manager:europe-west10:secrets-manager-db-dev-3631da18"
  image: "gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.8.0"
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "100m"

# Google Cloud Identity Platform Configuration
googleIdentity:
  enabled: true
  projectId: "cloud-secrets-manager"
  apiKey: ""  # Optional, set if needed
  serviceAccount:
    # Service account JSON should be provided as a Kubernetes secret (csm-google-service-account)
    secretName: "csm-google-service-account"
    key: "service-account.json"
  setupEnabled: false  # Disable setup endpoint in production

ingress:
  enabled: true
  className: "nginx"
  host: "secrets.local"
  tls:
    enabled: false  # Set to true when you have TLS certificates
    secretName: "secrets-manager-tls"
    # For Let's Encrypt with cert-manager, use:
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$1
    # Rate limiting (requests per minute per IP)
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-connections: "10"
    # DDoS protection
    nginx.ingress.kubernetes.io/limit-whitelist: ""  # Add trusted IPs if needed
    # Security headers
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/ssl-protocols: "TLSv1.2 TLSv1.3"
    # CORS (if needed)
    # nginx.ingress.kubernetes.io/enable-cors: "true"
    # nginx.ingress.kubernetes.io/cors-allow-origin: "https://yourdomain.com"

